### 回溯算法

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&scene=21#wechat_redirect



#### 框架

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



全排列

[46. 全排列](https://leetcode.cn/problems/permutations/)

7min 回溯，自己写出来了

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permute(vector<int>& nums) {
        // 2022-5-17 21:29:53 回溯框架
        vector<int> path;
        backtrack(nums, path);
        return res;
    }

    void backtrack(vector<int>& nums, vector<int>& path){
        if(nums.size() ==  path.size()){ // 满足结束条件
            res.push_back(path);
            return;
        }
        for(int i=0; i<nums.size(); i++){ // 遍历选择
            // 判断是否已经使用
            if(find(path.begin(), path.end(), nums[i]) != path.end()) continue; // 过滤选择
            // 做选择
            path.push_back(nums[i]);
            
            backtrack(nums, path);
            
            // 撤销选择
            path.erase(path.end()-1);
        }
    }
};
```



## [回溯算法秒杀所有排列/组合/子集问题](https://labuladong.github.io/algo/4/29/105/)

##### 题目

|                             力扣                             |        时间        | 难度 |          备注           |
| :----------------------------------------------------------: | :----------------: | :--: | :---------------------: |
|    [78. 子集](https://leetcode-cn.com/problems/subsets/)     |                    |  🟠   |                         |
| [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)  |                    |  🟠   |                         |
|  [77. 组合](https://leetcode-cn.com/problems/combinations/)  |                    |  🟠   |                         |
| [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) |                    |  🟠   |                         |
| [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |                    |  🟠   |                         |
| [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/) |                    |  🟠   |                         |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/) | 2022-5-17 21:29:53 | 中等 | 7min 回溯，自己写出来了 |
| [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) |                    |  🟠   |                         |



### 子集问题

**我们通过保证元素之间的相对顺序不变来防止出现重复的子集**。



### 组合（元素无重不可复选）

如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。

你比如说，让你在 `nums = [1,2,3]` 中拿 2 个元素形成所有的组合，你怎么做？

稍微想想就会发现，大小为 2 的所有组合，不就是所有大小为 2 的子集嘛。

**所以我说组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

反映到代码上，只需要稍改 base case，控制算法仅仅收集第 `k` 层节点的值即可。



## 括号题目

| 题目                                                         | 时间               | 难度 | 备注      |
| ------------------------------------------------------------ | ------------------ | ---- | --------- |
| [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/) | 2022-5-25 00:21:42 | 中等 | 10min, ok |
|                                                              |                    |      |           |
|                                                              |                    |      |           |



22. 括号生成

    ```c++
    class Solution {
    public:
        vector<string> generateParenthesis(int n) {
            // 2022-5-25 00:22:23 使用回溯，暴力遍历，先写回溯框架
            vector<string> res;
            string s = "";
            backtrace(n, n, res, s);
            return res;
        }
    
        void backtrace(int left, int right, vector<string>& res, string s){
            // 判断
            if(left <0 || right<0 || right<left) return;
            if(left == 0 && right == 0){
                res.push_back(s); // 合法括号
            }
    
            // 遍历
            // 添加一个左括号
            s.push_back('(');
            backtrace(left-1, right, res, s);
            s.pop_back();
    
            // 添加一个右括号
            s.push_back(')');
            backtrace(left, right-1, res, s);
            s.pop_back();
        }
    };
    ```

    
