# 动态规划

知乎专题：https://zhuanlan.zhihu.com/p/314995922



#### LC题目：一维

| 题目                                                         | 难度      | 时间              | 备注                                             |
| ------------------------------------------------------------ | --------- | ----------------- | ------------------------------------------------ |
| [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) | 易        | 2022-5-5 10:09:23 | 简单                                             |
| [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) | 中        | 2022-5-5 10:46:14 | 转移方程很容易想到                               |
| [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/) | 中-再做做 | 2022-5-5 15:24:36 | 找不到状态转移方程，1234中4的状态如何和3扯上关系 |



#### 分割问题

| 题目                                                         | 难度 | 时间              | 备注                                                         |
| ------------------------------------------------------------ | ---- | ----------------- | ------------------------------------------------------------ |
| [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/) | 中   | 2022-5-5 15:57:40 | 看的题解，自己不会找转移方程                                 |
| [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/) | 中   | 2022-5-5 16:21:33 | 状态转移方程找对了，但是写了一个小时还没有完全通过。写的太复杂，好多判断 |
|                                                              |      |                   |                                                              |





#### 子序列问题

| 题目                                                         | 难度 | 时间              | 备注                                                         |
| ------------------------------------------------------------ | ---- | ----------------- | ------------------------------------------------------------ |
| [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) | 中   | 2022-5-8 16:51:51 | 看了题解，我没找到转移方程，转移方程dp[i]其实可以和之前所有dp[j]都有关系，而不只是i的前面两个<br />dp[i] = max(dp[i], dp[j] + 1); （num[i]>nums[j]的情况下） |
| [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) | 中   | 2022-5-8 17:09:22 | ok，自己做出来了，找到了状态转移方程                         |
| [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) | 易   | 2022-5-8 17:36:25 | 8min做出来，dp[i] = max(nums[i], dp[i-1]+nums[i]);           |
| [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) | 中   | 2022-5-8 17:46:46 | 14min，和上面1143完全一样，求一个字符串的最长回文序列，就是求和这个字符串的反转串的最长公共子序列！<br />还有另外一种动态规划方法，dp[i, j]表示i，j范围内的回文串长度，然后dp[i,i]=1,考虑s[i] 和 s[j]是否相等来转移，感觉这种方法更简单！ |



[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

题解中的答案：因为dp[i,j] 依赖于 dp[i+1, j-1] 所以要注意迭代的方向！！！i是从n-1开始迭代的，从最大的开始迭代，那么后面的i+1才能保证一直有值！！！

即i要从大到小迭代，j从小到大迭代！！！

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.length();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            char c1 = s[i];
            for (int j = i + 1; j < n; j++) {
                char c2 = s[j];
                if (c1 == c2) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

