# 杂项：

## apt update中Hit, Ign, Get区别：

When you use `apt-get update` it verifies if the same update indexes need downloading, if not it does not download the same updated indexes again.

- `Hit` means apt checked the timestamps on package list, those match and there are no changes.
- `Ign` means there are no changes in the pdiff index file, it wont bother downloading it again.
- `Get` means apt checked the timestamps on package list, there were changes and will be downloaded.

Nothing to be scared of, it just means there is no need to download updated indexes again, the ones you have are current.



### backports是什么

百度百科：Backport是将一个软件的*补丁*应用到比此补丁所对应的版本*更老的版本*的**行为**。
这里不是说某个软件，而是这个行为本身叫做Backport(一般的应用软件，代码本身并不依赖特定版本的系统)

比方说 16.10推出后，已经在16.10中运行的软件，会被backports到16.04中，甚至是14.04中。
那么，一般情况下，会有哪些软件会被backports到以前版本呢？



### ubuntu下配置全局代理

打开/etc/profile文件，在末尾加上这三行(password中`.`号不用转义可以直接使用)

```
export http_proxy=http://username:password@proxy_ip:port   #代表http代理
export https_proxy=http://proxy_ip:port  #代表https代理
export ftp_proxy=http://proxy_ip:port  #代表ftp代理
```

然后执行source /etc/profile 即可。

##### **测试**：

```
curl www.google.com
```

 或者

```
wget www.google.com
```

注意不能使用ping命令，因为ping走的是icmp协议，这里是不可行的。



### apt设置代理

```bash
vi /etc/apt/apt.conf
# 添加 密码中的点号不用特殊处理
Acquire::http::proxy "http://d50019115:password@proxy.huawei.com:8080/";
Acquire::https::proxy "https://d50019115:password@proxy.huawei.com:8080/";
Acquire::ftp::proxy "ftp://d50019115:password@proxy.huawei.com:8080/";
```



### 添加keys

```
curl -sSL 'http://keyserver.ubuntu.com/pks/lookup?op=get&search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654' | sudo apt-key add -
```



### 查看deb包依赖关系：

```bash
dpkg --info apache2_2.4.7-1ubuntu4.14_amd64.deb | grep Depends
```



### 创建本地repos:

```
cd /home/packages
dpkg-scanpackages . /dev/null | gzip -9c > Packages.gz
echo "deb [trusted=yes] file:/home/packages/ ./" >> /etc/apt/sources.list
```



### apt-get 允许不可信源：

The "Release" file is a manifest of hash values represent packages' authentication information. By default `apt-get` require this info to secure the source of your system software environment.

You can just add `--allow-insecure-repositories` or `--allow-unauthenticated` to `apt-get update` to make it work, though security warnings will still be given by apt.



### 提示NO_PUBKEY：1FE11567623A70C9

```bash
wget  -qO --no-check-certificate - https://downloads.paradigm4.com/key | sudo apt-key add -
```

如果有代理好像上面的命令无法成功，所以还可以手动访问这个网址，得到一串key值

```bash
vi paradigmkey
apt-key add paradigmkey
# 查看key
apt-key list
# 发现存在上面的这个70C9的key了
/etc/apt/trusted.gpg
--------------------
pub   rsa2048 2012-10-25 [SC]
      FBD5 6460 30ED BF14 D261  79A3 1FE1 1567 623A 70C9
uid           [ unknown] SciDB Autosign key
sub   rsa2048 2012-10-25 [E]
```



#### OpenPGP keyserver:

https://keyserver.ubuntu.com/



------

## 2022年1月12日09:44:47

#### 修复安装错误的软件

```bash
# 会移除没有成功安装的软件
apt --fix-broken install
```



#### RXE在Windows平台git下载失败

之前使用git下载RDMA rxe的git版本库，结果一直失败，提示两个文件不存在，很奇怪，因为这两个文件github仓库里面也有，后来尝试手动将这两个文件直接放到本地文件夹中，发现重名了的时候，不允许使用这个文件名称，百度才知道，这些名字是保留名字：

```
CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9
```

[Windows 10 Still Won’t Let You Use These File Names Reserved in 1974](https://www.howtogeek.com/fyi/windows-10-still-wont-let-you-use-these-file-names-reserved-in-1974/)

------

2022-1-17 14:49:08

#### ubuntu开启x11-forwarding

https://blog.csdn.net/weixin_41668084/article/details/113361765

#### 安装x11

```bash
# 安装x11支持 
sudo apt-get install libx11-dev libxext-dev libxtst-dev libxrender-dev libxmu-dev libxmuu-dev

# /etc/ssh/sshd_config 中 x11 forward 参数设置为yes，ubuntu20.04我看默认是开启了的

# 安装x11-apps
apt install x11-apps

# 运行xclock
xclock （显示时钟）
xclock -d (显示数字)

# 安装并运行firefox
apt install firefox
firefox
```



#### 删除Linux环境变量

```
unset LD_LIBRARY_PATH
```



#### 动态链接库的查找先后顺序为：https://zhuanlan.zhihu.com/p/235551437

- `LD_LIBRARY_PATH`环境变量中的路径
- `/etc/ld.so.cache`缓存文件
- `/usr/lib`和`/lib`

比如，我们把CUDA安装到`/opt`下面，我们可以使用下面的命令将CUDA添加到环境变量里。

```bash
# 查看
echo ${LD_LIBRARY_PATH}

# 添加环境变量
export LD_LIBRARY_PATH=/home/rdmacore/rdma-core-master/build/lib/:$LD_LIBRARY_PATH

# 清空环境变量
unset LD_LIBRARY_PATH
```

除了`LD_LIBRARY_PATH`环境变量外，还有一个`LD_PRELOAD`环境变量。`LD_PRELOAD`的查找顺序比`LD_LIBRARY_PATH`还要优先。`LD_PRELOAD`里是具体的目标文件列表（A list of shared objects）；`LD_LIBRARY_PATH`是目录列表（A list of directories）。



#### 添加so文件路径到共享库：

```bash
vi /etc/ld.so.conf

# 添加一行
/home/link/testso （注意：include是用来添加一个文件夹用的，只添加一个目录的话，直接在这个文件最下面append一行即可）

# 刷新ld.so.cache
ldconfig
```



###### 注意：配置了/etc/ld.so.conf 运行ldconfig 编译仍找不到动态库

ld.so是动态库载入器而不是连接器，某些翻译“动态连接器”有问题的，或者说英文原文就有问题

换句话说，配置ld.so.conf的作用就是如果so在非标准路径，可执行文件能够找到，这是运行期做的事情

**你现在是编译，ld.so根本不起作用，所有用非标准路径的话必需手动指定库目录**



#### /usr/bin/ld 搜索路径顺序：

###### 一. **静态库链接**时搜索路径顺序 

1. ld会去找GCC命令中的参数-L
2. 再找gcc的环境变量LIBRARY_PATH
3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的  

###### 二. 动态链接时、执行时搜索路径顺序: 

```
1. 编译目标代码时指定的动态库搜索路径

2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径

3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径

4. 默认的动态库搜索路径/lib 

5. 默认的动态库搜索路径/usr/lib  
```

###### 三. 有关环境变量

```
LIBRARY_PATH环境变量：指定程序**静态链接库**文件搜索路径
```

```bash
# 查看
echo ${LIBRARY_PATH}
echo ${LD_LIBRARY_PATH}

# 添加环境变量，终于解决了 /usr/bin/ld: cannot find -lrdmacm 的问题!!!
export LIBRARY_PATH=$LIBRARY_PATH:/home/rdmacore/rdma-core-master/build/lib/

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/rdmacore/rdma-core-master/build/lib/
```

```
LD_LIBRARY_PATH环境变量：指定程序**动态链接库**文件搜索路径
```

dz: 静态库只是链接ld的时候起作用，运行时没作用，动态库链接的时候要去拿符号表，运行时也要用

**gcc -L可以直接指定库的路径：这样也能找到-lrdmacm库**

```
gcc -lrt  -L/home/rdmacore/rdma-core-master/build/lib/ -lrdmacm  devices.o   -o devices
```



##### 生成动态链接库：

```
$gcc -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 hello.o
```

另外再建立两个符号连接：

```
$ln -s libhello.so.1.0 libhello.so.1

$ln -s libhello.so.1 libhello.so
```

这样1个libhello的动态连接库就生成了。最重要的是传gcc -shared 参数使其生成是动态库而不是普通履行程序。 -Wl 表示后面的参数也就是-soname,libhello.so.1直接传给连接器ld进行处理。实际上，每个库都有1个soname，当连接器发现它正在查找的程序库中有这样1个名称，连接器便会将soname嵌入连结中的2进制文件内，而不是它正在运行的实际文件名，在程序履行期间，程序会查找具有 soname名字的文件，而不是库的文件名，换句话说，soname是库的辨别标志。 这样做的目的主要是允许系统中多个版本的库文件共存，习惯上在命名库文件的时候通常与soname相同 libxxxx.so.major.minor 其中，xxxx是库的名字，major是主版本号，minor 是次版本号







```
lsmod 查看内核模块
```



##### docker相关：

```
docker run -d --name fwd_sig registry/fwd_sig:v1 /c-init-sig 
```

之前已经启动一次了，重新启动的时候，会报错：Error response from daemon: Conflict. The container name "/fwd_sig" is already in use by container e3274a72e8d62a0f3022d3201405ce586147b3031c1232452d001ee41fb9c938. You have to remove (or rename) that container to be able to reuse that name..（容器名被占用，须移除或重命名后才能使用这个容器名。）

解决办法：

```
# 先查看所有的容器
docker ps -a
# 删除之前的容器就OK了
docker rm e327

# 或者直接运行之前的容器
docker start e327

# 如果要停止某个容器的运行
docker stop e327
```



```
# 追踪某个线程
strace -p 15909
```



##### linux配置端口转发：

在Linux的下面部署了tomcat，为了安全我们使用非root用户进行启动，但是在域名绑定时无法直接访问80端口号。众所周知，在unix下，非root用户不能监听1024以上的端口号，这个tomcat服务器就没办法绑定在80端口下。所以这里需要使用linux的端口转发机制，把到80端口的服务请求都转到8080端口上。

在root账户下面运行一下命令：

```
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
```

注意：网上朋友的命令dport 前面都是 一个 -，通常都会报错。另外如果防火墙重新启动，该命令就会失效。

可以使用下面的命令把该规则保存到iptables里面 ：

```
service iptables save
```



##### 端口映射：

pgw_ip:205.55.128.108 

```
iptables -t nat -A PREROUTING -p tcp --dport 31942 -j DNAT --to 205.55.128.108:31943
iptables -t nat -A POSTROUTING -p tcp -d 205.55.128.108 --dport 31943 -j SNAT --to 205.55.128.236:31942
```



###### 设置编译时候的预处理环境变量：

https://blog.csdn.net/weixin_44327262/article/details/105860213

https://www.cnblogs.com/linuxbo/p/4301716.html

```
export C_INCLUDE_PATH=$C_INCLUDE_PATH:/somewhere/include
```





------

2022年2月10日14:38:04



##### 静态库，动态库，头文件区别：

https://blog.csdn.net/weixin_42458272/article/details/106193786

静态库，动态库：

https://blog.csdn.net/qq_22122811/article/details/78226835

linux默认的头文件在 /usr/include里面，比如 stdio.h stdlib.h string.h

网络编程的在/usr/include/netinet里面

如果你的头文件在其他地方，gcc编译的时候，加上 -I （i:include）指定路径即可

```bash
# 解决了找不到 <rdma/rdma_cma.h>的问题
gcc -I /home/rdmacore/rdma-core-master/build/include/ yyy.c
```



##### "undefined reference to XXX"问题总结

好文章！！TODO，全文收藏起来！！

https://zhuanlan.zhihu.com/p/81681440

https://www.cnblogs.com/quant-lee/p/6639008.html



查看so文件是64位还是32位：

```bash
file librdmacm.so.1.3.39.0
# 输出
librdmacm.so.1.3.39.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=4fc4259f149d1fcdb1b7c215b662bf4fb8fe5ef9, with debug_info, not stripped
# 也可以使用 readelf -h <file> 输出格式更好看
readelf -h librdmacm.so.1.3.39.0
```