#### 大端(Big-Endian)和小端(little-Endian)的起源

关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。
战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，
因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，
其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，
先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，
第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。

#### 大端小端之分

小端字节序和大端字节序表示存储的字节顺序有区别
**小端字节序**：低字节存于内存低地址；高字节存于内存高地址;
long型数据0x12345678
在小端系统中，

| 地址       | 数据 |
| ---------- | ---- |
| 0x00000100 | 0x78 |
| 0x00000101 | 0x56 |
| 0x00000102 | 0x34 |
| 0x00000103 | 0x12 |

内存的地址是由低到高的顺序；而数据的字节也是由低到高的

**大端字节序**：高字节存于内存低地址；低字节存于内存高地址;
long型数据0x12345678
在大端系统中，

| 地址       | 数据 |
| ---------- | ---- |
| 0x00000100 | 0x12 |
| 0x00000101 | 0x34 |
| 0x00000102 | 0x56 |
| 0x00000103 | 0x78 |

内存的地址是由低到高的顺序；而数据的字节却是由高到低的

**网络字节序**
网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;
**UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,**这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;
所以说,网络字节序是大端字节序;比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;

**常见CPU的字节序**
Big Endian : PowerPC、IBM、Sun
Little Endian : x86、DEC
ARM既可以工作在大端模式，也可以工作在小端模式。